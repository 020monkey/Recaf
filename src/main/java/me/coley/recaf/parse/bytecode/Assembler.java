package me.coley.recaf.parse.bytecode;

import me.coley.recaf.parse.bytecode.ast.*;
import me.coley.recaf.util.AccessFlag;
import org.objectweb.asm.tree.*;
import org.objectweb.asm.tree.analysis.Frame;

import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Bytecode assembler.
 *
 * @author Matt
 */
public class Assembler {
	private final String declaringType;
	private Map<AbstractInsnNode, AST> insnToAST;

	/**
	 * @param declaringType
	 * 		Internal name of class declaring the method to be assembled.
	 */
	public Assembler(String declaringType) {
		this.declaringType = declaringType;
	}


	/**
	 * @param result
	 * 		AST parse result.
	 *
	 * @return Generated {@link MethodNode}.
	 *
	 * @throws AssemblerException
	 * 		<ul>
	 * 		<li>When the given AST contains errors</li>
	 * 		<li>When the given AST is missing a definition</li>
	 * 		</ul>
	 */
	public MethodNode compile(ParseResult<RootAST> result) throws AssemblerException {
		if(!result.isSuccess()) {
			ASTParseException cause = result.getProblems().get(0);
			AssemblerException ex  = new AssemblerException(cause, "AST must not contain errors", cause.getLine());
			throw ex;
		}
		RootAST root = result.getRoot();
		// Get definition
		DefinitionAST definition = root.search(DefinitionAST.class).stream().findFirst().orElse(null);
		if (definition == null)
			throw new AssemblerException("AST must have definition statement");
		int access = toAccess(definition);
		String name = definition.getName().getName();
		String desc = toDesc(definition);
		String[] exceptions = toExceptions(root);
		MethodNode node = new MethodNode(access, name, desc, null, exceptions);
		// Create label mappings
		Map<String, LabelNode> labels = new HashMap<>();
		root.search(LabelAST.class).forEach(lbl -> labels.put(lbl.getName().getName(), new LabelNode()));
		// Parse try-catches
		for(TryCatchAST tc : root.search(TryCatchAST.class)) {
			LabelNode start = labels.get(tc.getLblStart().getName());
			if(start == null)
				throw new AssemblerException("No label associated with try-catch start: " +
						tc.getLblStart().getName(), tc.getLine());
			LabelNode end = labels.get(tc.getLblEnd().getName());
			if(end == null)
				throw new AssemblerException("No label associated with try-catch end: " +
						tc.getLblEnd().getName(), tc.getLine());
			LabelNode handler = labels.get(tc.getLblHandler().getName());
			if(handler == null)
				throw new AssemblerException("No label associated with try-catch handler: " +
						tc.getLblHandler().getName(), tc.getLine());
			String type = tc.getType().getType();
			node.tryCatchBlocks.add(new TryCatchBlockNode(start, end, handler, type));
		}
		// Parse variables (name to index)
		Variables variables = new Variables(AccessFlag.isStatic(access), declaringType);
		variables.visit(root);
		// Parse instructions
		insnToAST = new HashMap<>();
		node.instructions = new InsnList();
		for(AST ast : root.getChildren()) {
			AbstractInsnNode insn;
			if(ast instanceof LabelAST)
				insn = labels.get(((LabelAST) ast).getName().getName());
			else if(ast instanceof Instruction)
				insn = ((Instruction) ast).compile(labels, variables);
			else
				continue;
			node.instructions.add(insn);
			insnToAST.put(insn, ast);
		}
		// Parse variables again (2nd pass to allow easier type analysis)
		node.maxStack = 0xFF;
		node.maxLocals = variables.getMax();
		variables.fillMissingTypes(root);
		node.localVariables = variables.getVariables(labels);
		return node;
	}

	/**
	 * @param definition
	 * 		AST of definition. Contains modifier AST children.
	 *
	 * @return Combined value of modifier children.
	 */
	private int toAccess(DefinitionAST definition) {
		return definition.search(DefinitionModifierAST.class).stream()
				.mapToInt(DefinitionModifierAST::getValue)
				.reduce(0, (a, b) -> a | b);
	}

	/**
	 * @param definition
	 * 		AST of definition. Contains argument AST children and return type child.
	 *
	 * @return Combined method descriptor of argument children and return type child.
	 */
	private String toDesc(DefinitionAST definition) {
		String args = definition.search(DefinitionArgAST.class).stream()
				.map(ast -> ast.getDesc().getDesc())
				.collect(Collectors.joining());
		String end = definition.getReturnType().getDesc();
		return "(" + args + ")" + end;
	}

	/**
	 * @param root
	 * 		AST of method.
	 *
	 * @return All thrown types.
	 */
	private String[] toExceptions(RootAST root) {
		return root.search(ThrowsAST.class).stream()
				.map(ast -> ast.getType().getType())
				.toArray(String[]::new);
	}

	/**
	 * Verify the generated method.
	 *
	 * @param generated
	 * 		Method generated by this assembler.
	 *
	 * @return Analyzed frames of the method.
	 *
	 * @throws AssemblerException
	 * 		Wrapped verification exception.
	 */
	public Frame<RValue>[] verify(MethodNode generated) throws AssemblerException {
		return new Verifier(this, declaringType).verify(generated);
	}

	/**
	 * @param insn
	 * 		Generated instruction.
	 *
	 * @return Line instruction was generated from.
	 */
	public int getLine(AbstractInsnNode insn) {
		if (insnToAST == null)
			return -1;
		AST ast = insnToAST.get(insn);
		return ast != null ? ast.getLine() : -1;
	}
}
