package me.coley.recaf.parse.assembly.visitors;

import me.coley.recaf.parse.assembly.LineParseException;
import me.coley.recaf.parse.assembly.Visitor;
import me.coley.recaf.parse.assembly.parsers.OpParser;
import me.coley.recaf.util.*;
import org.objectweb.asm.tree.*;

import java.util.*;
import java.util.function.Function;

import static org.objectweb.asm.tree.AbstractInsnNode.*;

/**
 * Visitor that parses a body of instructions.
 *
 * @author Matt
 */
// TODO: Emitter interface that emits assembly from a methodnode
public class AssemblyVisitor implements Visitor {
	private static final Map<Integer, Function<AssemblyVisitor, Visitor>> visitors =
			new HashMap<>();
	private int line;
	private InsnList insnList;
	// Locals
	// Try-catch ranges
	// Aliases

	/**
	 * @param insn
	 * 		Instruction to append to the instructions list.
	 */
	public void appendInsn(AbstractInsnNode insn) {
		insnList.add(insn);
	}

	/**
	 * @return Method instructions generated by {{@link #visit(String)}}.
	 */
	public InsnList getInsnList() {
		return insnList;
	}

	@Override
	public void visit(String text) throws LineParseException {
		// Iterate over lines in two passes:
		// - Debug collection
		// - Instruction parsing
		try {
			insnList = new InsnList();
			line = 1;
			String[] lines = StringUtil.splitNewline(text);
			for(String lineStr : lines) {
				getVisitor(lineStr).visitPre(lineStr);
				line++;
			}
			line = 1;
			for(String lineStr : lines) {
				getVisitor(lineStr).visit(lineStr);
				line++;
			}
		} catch(LineParseException ex) {
			// Some exceptions deeper in the visitor tree don't have access to the line.
			// So before we throw this, make sure it has the line.
			if (ex.getLine() == -1)
				ex.setLine(line);
			// Now throw it
			throw ex;
		}
	}

	/**
	 * @param lineStr
	 * 		Text to get suggestions for.
	 *
	 * @return List of suggestions for the last section of the chain parse list.
	 *
	 * @throws LineParseException
	 * 		When one of the parsers fails to interpret the line.
	 */
	public List<String> suggest(String lineStr) throws LineParseException {
		InstructionVisitor visitor;
		try {
			// Try to get visitor from instruction specified by the line.
			visitor = (InstructionVisitor) getVisitor(lineStr);
		} catch(LineParseException ex) {
			// Can't find an instruction? Suggest instructions!
			return new OpParser().suggest(lineStr);
		}
		// If the instruction is valid, use the instruction visitor's suggestions.
		return visitor.suggest(lineStr);
	}

	/**
	 * @param text
	 * 		Text that has a leading instruction token.
	 *
	 * @return Visitor to parse the line.
	 *
	 * @throws LineParseException
	 * 		When the line does not have any identifier that links to an existing visitor
	 * 		implementation.
	 */
	private Visitor getVisitor(String text) throws LineParseException {
		return getVisitor(line, text);
	}

	/**
	 * @param text
	 * 		Text that has a leading instruction token.
	 * @param line
	 * 		The line the text resides on.
	 *
	 * @return Visitor to parse the line.
	 *
	 * @throws LineParseException
	 * 		When the line does not have any identifier that links to an existing visitor
	 * 		implementation.
	 */
	public Visitor getVisitor(int line, String text) throws LineParseException {
		String word = RegexUtil.getFirstWord(text);
		if(word != null) {
			String token = word.toUpperCase();
			if (OpcodeUtil.getInsnNames().contains(token)) {
				int opcode = OpcodeUtil.nameToOpcode(token);
				int type = OpcodeUtil.opcodeToType(opcode);
				if(visitors.containsKey(type))
					return visitors.get(type).apply(this);
			}
			throw new LineParseException(line, text, "Could not determine instruction: " + token);
		}
		throw new LineParseException(line, text, "Could not determine instruction. no content");
	}

	static {
		visitors.put(INSN, InsnVisitor::new);
	}
}
