package me.coley.recaf.parse.assembly.visitors;

import me.coley.recaf.parse.assembly.*;
import me.coley.recaf.parse.assembly.parsers.OpParser;
import me.coley.recaf.util.*;
import org.objectweb.asm.tree.*;
import org.objectweb.asm.tree.analysis.*;

import java.util.*;
import java.util.function.Function;

import static org.objectweb.asm.tree.AbstractInsnNode.*;
import static me.coley.recaf.util.OpcodeUtil.CATCH_INSN;
import static me.coley.recaf.util.OpcodeUtil.THROWS_INSN;
import static me.coley.recaf.util.OpcodeUtil.COMMENT_INSN;

/**
 * Visitor that parses a body of instructions.
 *
 * @author Matt
 */
public class AssemblyVisitor implements Visitor<String> {
	private static final Map<Integer, Function<AssemblyVisitor, Visitor<String>>> visitors =
			new HashMap<>();
	private int line;
	private MethodNode method;
	private Map<AbstractInsnNode, Integer> insnToLine = new HashMap<>();
	private Variables variables = new Variables();
	private Labels labels = new Labels();
	// TODO: Aliases
	private boolean addVariables;
	// Method definition
	private int access;
	private String desc;

	/**
	 * Registers variables to <i>"this"</i> and method paramters.
	 *
	 * @param access
	 * 		Method access flag mask.
	 * @param desc
	 * 		Method descriptor.
	 */
	public void setupMethod(int access, String desc) {
		this.access = access;
		this.desc = desc;
		variables.setup(access, desc);
	}

	/**
	 * @param addVariables
	 * 		Flag to generate variable information in the generated method.
	 */
	public void setDoAddVariables(boolean addVariables) {
		this.addVariables = addVariables;
	}

	/**
	 * @param insn
	 * 		Instruction to append to the instructions list.
	 */
	public void appendInsn(AbstractInsnNode insn) {
		method.instructions.add(insn);
		insnToLine.put(insn, line);
	}

	/**
	 * @param trycatch
	 * 		Try-catch block to append to the method catch list.
	 */
	public void appendCatch(TryCatchBlockNode trycatch) {
		method.tryCatchBlocks.add(trycatch);
	}

	/**
	 * @param type
	 * 		Type for the method to throw.
	 */
	public void appendThrows(String type) {
		method.exceptions.add(type);
	}

	/**
	 * @return Method generated by {{@link #visit(String)}}.
	 */
	public MethodNode getMethod() {
		return method;
	}

	/**
	 * @return Method instructions generated by {{@link #visit(String)}}.
	 */
	public InsnList getInsnList() {
		return method.instructions;
	}

	/**
	 * @return Variable manager.
	 */
	public Variables getVariables() {
		return variables;
	}

	/**
	 * @return Label manager.
	 */
	public Labels getLabels() {
		return labels;
	}

	@Override
	public void visit(String text) throws LineParseException {
		// Iterate over lines in two passes:
		// - Debug collection
		// - Instruction parsing
		try {
			// reset
			insnToLine.clear();
			labels.reset();
			variables.reset();
			if (desc != null)
				variables.setup(access, desc);
			// Setup method to fill
			method = new MethodNode();
			method.localVariables = new ArrayList<>();
			method.tryCatchBlocks = new ArrayList<>();
			method.exceptions = new ArrayList<>();
			method.access = access;
			method.desc = desc;
			method.name = "assembled";
			// Preparse
			line = 1;
			String[] lines = StringUtil.splitNewline(text);
			for(String lineStr : lines) {
				getVisitor(lineStr).visitPre(lineStr);
				line++;
			}
			// TODO: When adding alias support, update strings in "lines"
			// Add instructions to method
			line = 1;
			for(String lineStr : lines) {
				getVisitor(lineStr).visit(lineStr);
				line++;
			}
			// Add variable information to method
			method.maxLocals = variables.nextIndex();
			if (addVariables) {
				method.instructions.insert(labels.getStart());
				method.instructions.add(labels.getEnd());
				method.localVariables.addAll(variables.create(labels.getStart(), labels.getEnd()));
			}
		} catch(LineParseException ex) {
			// Some exceptions deeper in the visitor tree don't have access to the line.
			// So before we throw this, make sure it has the line.
			if (ex.getLine() == -1)
				ex.setLine(line);
			// Now throw it
			throw ex;
		}
	}

	/**
	 * Run the generated method through a basic verifier.
	 *
	 * @throws VerifyException
	 * 		When the code failed to pass verification.
	 */
	public void verify() throws VerifyException {
		try {
			// We "could" analyze the stack beforehand.... Nah
			method.maxStack = 0xFF;
			// Run analysis
			new Analyzer<>(new BasicVerifier()).analyze("Assembled", method);
		} catch(AnalyzerException ex) {
			// Thrown on failure.
			throw new VerifyException(ex, "Verification failed on line: " + insnToLine.get(ex.node)
					+ "\n" + ex.getMessage());
		} catch(IndexOutOfBoundsException ex) {
			// Thrown when local variables are messed up.
			throw new VerifyException(ex, null);
		} catch(Exception ex) {
			// Unknown error
			throw new VerifyException(ex, "Unknown error");
		}
	}

	/**
	 * @param lineStr
	 * 		Text to get suggestions for.
	 *
	 * @return List of suggestions for the last section of the chain parse list.
	 *
	 * @throws LineParseException
	 * 		When one of the parsers fails to interpret the line.
	 */
	public List<String> suggest(String lineStr) throws LineParseException {
		InstructionVisitor visitor;
		try {
			// Try to get visitor from instruction specified by the line.
			visitor = (InstructionVisitor) getVisitor(lineStr);
		} catch(LineParseException ex) {
			// Can't find an instruction? Suggest instructions!
			return new OpParser().suggest(lineStr);
		}
		// If the instruction is valid, use the instruction visitor's suggestions.
		try {
			// Fill the Parser chain values
			// - May throw 'LineParseException' since we're completing incompleted data.
			//   So this exception is expected and can be ignored here.
			visitor.parse(lineStr);
		} catch(LineParseException ex) {
			// Do nothing, we're expecting this
		}
		return visitor.suggest(lineStr);
	}

	/**
	 * @param insn
	 * 		Instruction to search for.
	 *
	 * @return Line number the instruction was generated from. {@code -1} if the instruction does
	 * not belong to the most recent generated method.
	 */
	public int getLine(AbstractInsnNode insn) {
		return insnToLine.getOrDefault(insn, -1);
	}

	/**
	 * @param text
	 * 		Text that has a leading instruction token.
	 *
	 * @return Visitor to parse the line.
	 *
	 * @throws LineParseException
	 * 		When the line does not have any identifier that links to an existing visitor
	 * 		implementation.
	 */
	private Visitor<String> getVisitor(String text) throws LineParseException {
		return getVisitor(line, text);
	}

	/**
	 * @param text
	 * 		Text that has a leading instruction token.
	 * @param line
	 * 		The line the text resides on.
	 *
	 * @return Visitor to parse the line.
	 *
	 * @throws LineParseException
	 * 		When the line does not have any identifier that links to an existing visitor
	 * 		implementation.
	 */
	public Visitor<String> getVisitor(int line, String text) throws LineParseException {
		String word = RegexUtil.getFirstWord(text);
		if(word != null) {
			String token = word.toUpperCase();
			if (OpcodeUtil.getInsnNames().contains(token)) {
				int opcode = OpcodeUtil.nameToOpcode(token);
				int type = OpcodeUtil.opcodeToType(opcode);
				if(visitors.containsKey(type))
					return visitors.get(type).apply(this);
			}
			throw new LineParseException(line, text, "Could not determine instruction: " + token);
		}
		throw new LineParseException(line, text, "Could not determine instruction. no content");
	}

	static {
		visitors.put(INSN, InsnVisitor::new);
		visitors.put(LINE, LineVisitor::new);
		visitors.put(LABEL, LabelVisitor::new);
		visitors.put(INT_INSN, IntVisitor::new);
		visitors.put(LDC_INSN, LdcVisitor::new);
		visitors.put(VAR_INSN, VarVisitor::new);
		visitors.put(IINC_INSN, IincVisitor::new);
		visitors.put(JUMP_INSN, JumpVisitor::new);
		visitors.put(TYPE_INSN, TypeVisitor::new);
		visitors.put(CATCH_INSN, CatchVisitor::new);
		visitors.put(FIELD_INSN, FieldVisitor::new);
		visitors.put(METHOD_INSN, MethodVisitor::new);
		visitors.put(THROWS_INSN, ThrowsVisitor::new);
		visitors.put(COMMENT_INSN, CommentVisitor::new);
		visitors.put(TABLESWITCH_INSN, TableSwitchVisitor::new);
		visitors.put(LOOKUPSWITCH_INSN, LookupSwitchVisitor::new);
		visitors.put(INVOKE_DYNAMIC_INSN, InvokeDynamicVisitor::new);
		visitors.put(MULTIANEWARRAY_INSN, MultiANewArrayVisitor::new);
	}
}
